# HEPWALTER

## Searching candidate function from command line
The details surrounding HEPWALTER are explored in finer granularity in the corresponding paper. At a high level, the microservices are distributed to nodes, candidate functions for specific microservices are recorded (print_candidate_functions.py), BPFtrace for specified functions generated (prepare.py), and redundancy data gathered (main.py).

Here are the End to End commands:
1. Get microservice of interest running on Node 0 (Refer to Jaylen's script for instructions)
2. Confirm the singular container is running using "sudo docker stats"
3. Clone Deepanjali's perf_chain repo.
4. Follow these customized perf_chains instructions (inside that repo) to gather perf data

    a.) Use `sudo docker stats` to get container ID
   
    b.) Use `docker inspect --format '{{.State.Pid}}' <container-id>` to extract PID
   
    c.) `sudo perf record -j any_call,any_ret -p <microservice_pid> -- sleep <time_in_seconds>`

    d.) Place resulting perf.data into `perf_chains/` directory

    e.) Use `sudo chmod +x setup.sh` to install all necessary setup

    f.) Update path accordingly in symbolizer.py

    g.) `sudo chmod +rx perf.data` to set permissions.

    h.) Generate proto file using `sudo perf_converter -i perf.data -o perf.proto -O proto`

    i.) Recompile proto using
   
   `protoc --python_out=. ./profile.proto`
   
   `protoc --python_out=. ./perf_data.proto`

    j.) Copy `print_candidate_function.py` into this folder
   
    k.) `sudo python3 print_candidate_functions.py` to extract candidate functions

    l.) `sudo python3 print_candidate_functions.py > <container_name>.txt` to write candidate function
6. Follow the following instructions to generate customized BPFtrace script

    a.) Replace `container_name` in prepare.py with container name of interest.

    b.) The `bufflength` argument is modifiable. Change this value to fit the buffer length.
  
    c.) Gather container ID with `sudo docker stats`


    d.) Type `sudo docker exec -it <container_ID> /bin/bash` to enter into container
  
    e.) Use `top` and find the process with highest CPU utilization. Then type `which <binary>` to gather the binary
  
    f.) Copy and paste this path into the "binary" from prepare.py
  
7. Replace `Source` and `Destination` in prepare.py with candidate functions from `<container_name>.txt`. Ideally, choose a function that belongs under encryption, compression, or serialization (data center tax)
8. Run `python3 prepare.py`, this generates a `final_run_again.bt` file for bpftrace
9. The main.py is a script to execute the prepare.py and use BPFGrep to capture the outputs generated by bpftrace
10. The main function of main.py has three major variables: `iterations` `duration` `lost_threshold`

    a.)`iterations`: Number of iteration until lost event happens in bpftrace

    b.)`duration`: Time out value for the bpftrace command to termination of current iteration
  
    c.)`lost_threshold`: Number of counted lost event until termination of current iteration
  
12. The main.py calls the BPFGrep object and parses the bpftrace outputs. It then reports:

    a.) the total average bytes per function call out of data collect from all iterations
    
    b.) the max divergence length (in bytes and non-zero) out of all iterations
